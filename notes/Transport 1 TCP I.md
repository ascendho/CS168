# Transport 1: TCP I


## 一、传输层核心基础
### 1. 传输层的定位与核心功能
- **底层依赖**：基于IP层（L3）的数据包传输能力，但IP层仅提供“尽力而为”服务（可能丢包、损坏、乱序、延迟、重复）。
- **核心目标**：为应用层提供更实用的抽象，解决“不可靠传输”和“应用解复用”两大问题。
- **两大协议对比**：
  
  | 协议 | 核心功能 | 抽象类型 | 适用场景 |
  |------|----------|----------|----------|
  | TCP（传输控制协议） | 端口解复用 + 可靠性 | 可靠字节流（有序、无丢失、无损坏） | 文件传输、网页加载等需可靠传输的场景 |
  | UDP（用户数据报协议） | 仅端口解复用 | 不可靠数据报（与IP层一致） | 直播、游戏等对实时性要求高于可靠性的场景 |

### 2. 关键特性：端口解复用
- **作用**：通过16位端口号区分同一主机上的不同应用，配合IP层协议字段（区分TCP/UDP），实现“IP地址+协议+端口”的唯一标识。
- **端口分类**：临时端口（1024–65535，应用随机选择）、知名端口（如SSH 22、HTTP 80，公共服务固定使用）。
- **类比**：端口如同房屋的房间号，IP地址是房屋地址，确保数据准确交付到目标应用。

### 3. 实现原则：端到端原则
- 传输层功能（解复用、可靠性）仅在**端主机**实现，中间路由器不参与——无需改造网络核心设备，降低部署复杂度。


## 二、可靠性实现：核心机制
可靠性的目标是“数据正确（无丢失、无损坏、有序）、及时、高效”，分为单包和多包场景逐步实现。

### 1. 单包可靠性：解决5大问题
IP层可能出现5类问题，对应解决方案如下：
| 问题类型 | 解决方案 | 细节说明 |
|----------|----------|----------|
| 数据包丢失 | 超时重传 | 发送方发送数据包后启动计时器，超时未收到ack则重传；ack丢失也触发重传（符合“至少一次交付”） |
| 数据包损坏 | 校验和 + 静默丢弃 | 数据包添加校验和，接收方校验失败则忽略（不发nack），依赖发送方超时重传（TCP采用此方案） |
| 数据包延迟 | 计时器容错 | 只要ack在超时前到达即正常，延迟过长触发重传（视为丢失） |
| 数据包重复 | 去重处理 | 接收方通过后续机制（如序号）识别重复包并丢弃，最终向应用提供“恰好一次交付” |
| 数据包乱序 | 序号标记 | 单包场景无需额外处理，多包场景通过序号排序（后续展开） |

### 2. 核心机制总结
- 校验和：检测数据包损坏；
- 确认（ack）：接收方告知发送方“数据已正确接收”；
- 超时重传：应对丢包和ack丢失；
- 至少一次交付：先保证“不丢包”，再通过去重实现“恰好一次交付”。


## 三、多包可靠性：窗口机制
单包场景的“停止等待协议”（发送1个包后等待ack再发下一个）效率极低（1个包/RTT），窗口机制通过“允许多个包同时在途”提升吞吐量。

### 1. 窗口算法核心思想
- **在途包**：已发送但未收到ack的数据包；
- **窗口大小（W）**：同时允许在途的最大数据包数量；
- **工作流程**：
  1. 初始发送W个包，填满窗口；
  2. 每收到1个ack，就发送1个新包，保持窗口内有W个在途包；
  3. 核心优势：吞吐量提升至W个包/RTT，大幅降低延迟。

### 2. 窗口大小的3个设计目标（平衡效率与稳定性）
窗口大小需同时满足“不浪费带宽、不超载接收方、不超载网络”，最终取三者最小值：
| 目标 | 计算方式/机制 | 核心逻辑 |
|------|--------------|----------|
| 填满管道（最大化带宽） | W = RTT × 瓶颈链路带宽 | 确保发送方在RTT内持续发送数据，不空闲（如RTT=5s、带宽=10包/s，W=50） |
| 不超载接收方（流量控制） | 接收方“广告窗口” | 接收方通过ack告知剩余缓冲区大小，发送方在途包数量不超过该值（避免缓冲区溢出） |
| 不超载网络（拥塞控制） | 发送方“拥塞窗口（cwnd）” | 发送方通过算法动态计算网络可承载的带宽份额，避免链路拥堵（后续深入算法） |

### 3. 实际窗口取值
- 理想值：min（广告窗口，拥塞窗口）；
- 原因：拥塞窗口通常已≤管道填充窗口（共享带宽时更小），无需额外计算管道填充窗口。


## 四、智能确认策略
确认（ack）是可靠性的核心反馈机制，TCP选择“累积确认”以平衡效率和开销，三种确认策略对比：
| 确认类型 | 实现方式 | 优点 | 缺点 |
|----------|----------|------|------|
| 单独确认 | 收到包i就发送ack(i) | 简单、紧凑 | ack丢失必触发重传（即使数据已接收） |
| 全信息确认 | ack中列出所有已接收包 | 抗ack丢失、信息完整 | 丢包较多时，ack字段过长（开销大） |
| 累积确认（TCP采用） | ack中仅告知“已正确接收的最大连续序号n”（即1~n全收到） | 紧凑、抗ack丢失（优于单独确认） | 信息不完整，无法明确知道非连续包是否接收 |


## 五、早期丢包检测
仅依赖“超时重传”检测丢包效率低（超时时间≈RTT，毫秒级），引入“基于ack的快速重传”，大幅缩短丢包检测时间：
### 1. 核心逻辑
- 若收到k个后续包的ack（或重复ack），则判定中间包丢失（k=3为TCP默认值）；
- 例：收到ack(6)、ack(7)、ack(8)，但未收到ack(5) → 判定包5丢失，立即重传（无需等待超时）。

### 2. 不同确认策略的适配性
- 单独确认/全信息确认：直接通过ack缺口识别丢包（无歧义）；
- 累积确认：通过“重复ack”识别（如连续3个ack(n)，说明n+1及后续包已接收但n+1丢失），触发快速重传。

### 3. 多包丢失场景
- 累积确认存在歧义（如同时丢失包3和包5，仅收到重复ack(2)，无法区分是哪个包丢失），需依赖超时或额外 heuristics补充。


## 六、可靠性的替代设计
除了“超时重传”，还可通过“编码冗余”实现可靠性：
- **核心思想**：发送方对k个原始包进行编码，生成n个冗余包（n>k），接收方只要收到k'个包（k<k'<n）即可恢复原始数据；
- **优势**：无需重传，适配丢包率高的场景（如视频 streaming）；
- **典型编码**：喷泉码、 Raptor 码；
- **局限性**：编码/解码有开销，效率依赖k'/k的比值（冗余度）。


## 七、TCP核心设计选择总结
TCP的可靠性是一系列设计选择的结果，关键决策如下：
1. 损坏包处理：不发nack，静默丢弃依赖超时重传；
2. 确认策略：采用累积确认（平衡紧凑性和抗丢包）；
3. 丢包检测：超时重传 + 快速重传（3个重复ack）；
4. 流量控制：基于接收方广告窗口；
5. 拥塞控制：基于发送方拥塞窗口；
6. 抽象类型：可靠字节流（适配多数应用的有序数据需求）。

核心原则：理解“设计权衡”（如累积确认的歧义性 vs 开销），比记忆细节更重要——不同设计选择可衍生出不同的可靠性协议（如停止等待、Go-Back-N等）。