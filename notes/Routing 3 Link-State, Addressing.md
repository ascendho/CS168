# Routing 3: Link-State, Addressing

## 一、链路状态协议（Link-State Protocols）

链路状态协议是**域内网关协议（IGP）** 的核心类型，核心逻辑是“全局拓扑感知+本地最短路径计算”，与距离矢量协议形成鲜明对比。

### 1. 路由协议分类基础

路由协议按“运行范围”和“运行方式”可分为两类，具体对应关系如下：

| 运行方式       | 域内（Interior Gateway Protocol，IGP） | 域间（Exterior Gateway Protocol，EGP） |
|----------------|----------------------------------------|----------------------------------------|
| 距离矢量（Distance-vector） | RIP                                    | 无                                     |
| 链路状态（Link-state）     | IS-IS、OSPF                            | 无                                     |
| 路径矢量（Path-vector）    | 无                                     | BGP                                    |

链路状态协议的典型应用场景是**域内路由**（如企业、校园网络内部），代表协议为IS-IS和OSPF。


### 2. 链路状态协议的核心定义
链路状态协议通过两步实现路由：
1. **全局拓扑学习**：每个路由器获取完整的网络拓扑（所有链路、链路状态（通/断）、链路成本、所有目的地）；
2. **本地路径计算**：每个路由器基于拓扑独立运行最短路径算法，生成转发表（记录“目的地→下一跳”映射）。

#### 与距离矢量协议的关键区别
| 维度         | 距离矢量协议（Distance-vector）       | 链路状态协议（Link-state）             |
|--------------|----------------------------------------|----------------------------------------|
| 数据范围     | 局部数据（仅知道邻居告知的部分拓扑）   | 全局数据（掌握完整网络拓扑）           |
| 计算方式     | 分布式计算（依赖邻居逐步传递结果）     | 本地计算（独立基于拓扑求解）           |
| 信任机制     | 依赖邻居信息（“听邻居说”）             | 自主验证拓扑（“自己看全局”）           |


### 3. 路径计算（Computing Paths）
#### （1）最短路径算法选择
需满足“单源最短路径”需求（从当前路由器到所有目的地），可选算法包括：
- Bellman-Ford（串行原版）、Dijkstra算法（常用）；
- 广度优先搜索（BFS，适用于等成本链路）；
- 动态最短路径、近似最短路径、并行单源最短路径等。

#### （2）确保路由一致性的核心要求
若路由器计算逻辑不一致，会导致“路由环路”（如R2转发到R3，R3同时转发到R2）。需满足4个条件：
1. 所有路由器**一致认同网络拓扑**；
2. 所有路由器**最小化相同的成本 metric**（如链路带宽、延迟）；
3. 所有链路成本为**正值**（避免无限循环）；
4. 所有路由器使用**相同的破 tie 规则**（如成本相同时选IP更小的下一跳）。

注：无需强制使用相同算法，只要满足上述规则，结果即可兼容；实际中为简化操作，通常统一算法。


### 4. 网络拓扑学习（Learning Graph Topology）
路由器通过“邻居发现→信息泛洪”两步获取全局拓扑，同时解决泛洪的可靠性与安全性问题。

#### （1）步骤1：发现邻居（Learn Neighbors）
- 机制：路由器**定期发送“Hello消息”** 给直连邻居，告知自身身份；
- 断连检测：若邻居停止发送Hello消息，判定链路断开；
- 局限：仅能发现直连邻居（如R1仅知R2，不知R3），无法获取全局拓扑。

#### （2）步骤2：传播邻居信息（Propagate Neighbor Information）
- 核心方案：**泛洪（Flooding）** ——本地信息变化时，发送给所有邻居；收到邻居信息后，转发给除发送方外的所有邻居（确保全网覆盖）；
- 关键问题1：无限泛洪与信息放大（如R1→R2→R1→R2的循环，导致消息无限复制）；
  - 解决方案：为消息添加**唯一标识**（如时间戳、严格递增的序列号），收到已标识的消息则丢弃，不转发；
- 关键问题2：可靠性（网络为“尽力而为”服务，消息可能丢失）；
  - 解决方案：**定期重发更新**，确保所有路由器最终收到一致的拓扑信息；
- 关键问题3：收敛性（链路故障时，需等待“故障检测→泛洪新信息→重计算路径”，期间路由状态可能无效，导致数据包循环或丢失）。

### 5. 链路状态 vs. 距离矢量协议的优势

| 优势维度       | 链路状态协议（Link-state）             | 距离矢量协议（Distance-vector）       |
|----------------|----------------------------------------|----------------------------------------|
| 路径控制权     | 更高（基于全局拓扑自主选择路径）       | 更低（依赖邻居传递的路径信息）         |
| 收敛速度       | 更快（直接泛洪拓扑变化，无需等邻居重算） | 更慢（需等待邻居重算后再传递结果）     |
| 拓扑透明度     | 高（掌握全局拓扑，便于故障排查）       | 低（仅知邻居信息，拓扑不透明）         |

实际网络中常混合使用两种协议（如域内用OSPF/IS-IS，域间用BGP）。

## 二、IP地址（IP Addressing）

IP地址设计的核心目标是**解决路由扩展性问题**——避免路由器为每个主机维护一条路由表项，通过“分层地址+路由聚合”大幅简化路由。


### 1. 分层地址（Hierarchical Addressing）：解决路由扩展性的核心
#### （1）设计背景
早期路由表按“每个主机一条项”存储（如R3的表项包含A、B、C、D等所有目的地），当互联网主机数量激增时，路由表会无限膨胀，无法存储和计算。

#### （2）核心逻辑
互联网是“网络的网络”（如校园网、企业网互联），因此IP地址分为**网络号（标识网络）** 和**主机号（标识网络内主机）**：
- 路由器仅需为“每个网络”维护一条表项（而非每个主机）；
- 网络内的主机共享相同网络号，网络间的路由仅需关注网络号。

#### （3）关键优势
1. **路由表项大幅减少**：如R9的表项可聚合为“1.*→R6”“3.*→R6”“4.*→R8”，无需列出网络1内的所有主机（1.1、1.2等）；
2. **减少表项变动（Churn）**：网络内的主机增减（如网络4的4.6下线），不影响其他网络的路由表（R9的“4.*→R8”表项无需修改）；
3. **分工明确**：
   - 域间路由：计算“网络到网络”的路径（如网络1→网络2）；
   - 域内路由：计算“网络内主机到主机”的路径（如网络2内的2.1→2.2）。

#### （4）默认路由（Default Route）
当路由器无需区分具体外部网络时，可使用**通配符*.*** 表示“所有未匹配的目的地”，即默认路由：
- 例：R2的表项仅需“2.4→直连”“2.5→直连”“*.*→R3”，无需列出所有外部网络（1.*、3.*等）；
- 实际场景：大多数主机仅需配置默认路由（指向网关），简化配置。


### 2. 地址分配（Assigning Addresses）：从“分类”到“无类”的演进
IPv4地址为32位，地址分配经历三次关键尝试，核心是解决“网络号不足”与“地址浪费”问题。

#### （1）尝试1：早期互联网（8位网络号）
- 规则：前8位为**网络号**（全球唯一），后24位为**主机号**；
- 例：AT&T网络号为12，Apple为17，美国国防部占用13个网络号（6、7、11等）；
- 问题：
  - 网络号仅2^8=256个，远不能满足互联网规模；
  - 小网络（如仅10台主机的商店）需占用2^24=1677万主机号，严重浪费。

#### （2）尝试2：分类寻址（Classful Addressing）
- 思路：按“网络规模”分配不同长度的网络号，通过地址**前几位（前缀）区分地址类别**：
  | 地址类别 | 前缀标识 | 网络号长度 | 主机号长度 | 网络数量（约） | 单网络主机数（约） |
  |----------|----------|------------|------------|----------------|--------------------|
  | Class A  | 0开头    | 7位        | 24位       | 128            | 1600万             |
  | Class B  | 10开头   | 14位       | 16位       | 1.6万          | 6.5万              |
  | Class C  | 110开头  | 21位       | 8位        | 200万          | 256                |
- 问题：
  - Class A太大（仅128个网络，多数组织用不起），Class C太小（仅256台主机，多数组织不够用）；
  - Class B成为折中选择，但仅1.6万个网络号，仍会耗尽；且6.5万主机号对多数组织仍显浪费。

#### （3）尝试3：无类域间路由（CIDR，Classless Inter-Domain Routing）
- 核心突破：**打破8位边界**，允许网络号为“任意长度”（而非固定7/14/21位），通过“斜线记法”标识网络号长度；
- 解决浪费问题：按需分配网络号长度，匹配实际主机数量；
  - 例：某商店需450台主机，需主机号长度为9位（2^9=512，满足450台需求），网络号长度为32-9=23位，避免Class B的6.5万主机号浪费；
- 分层分配流程（确保全局唯一）：
  1. ICANN（互联网名称与数字地址分配机构）：管理所有IP地址；
  2. RIRs（区域互联网注册机构）：ICANN分配块给五大区域（如ARIN覆盖北美、APNIC覆盖亚太）；
  3. 大型组织/ISP：从RIRs获取地址块，再分配给下属；
  4. 小型组织/个人：从ISP获取小地址块（如教授的个人地址为32位固定，无主机号）。


### 3. 地址书写（Writing Addresses）：斜线记法与子网掩码
IPv4地址的书写需兼顾“人类可读性”与“机器可计算性”，核心有两种方式：

#### （1）点分四组（Dotted Quad）
- 规则：将32位地址分为4个8位块，每个块转换为十进制，用点分隔；
- 例：二进制`11011100 11101000 10011010 01011101` → 十进制`220.232.154.93`。

#### （2）斜线记法（Slash Notation）
- 规则：`[点分四组地址]/[网络号长度]`，表示“前N位为网络号，后32-N位为主机号”；
- 例：
  - `192.168.1.0/24`：24位网络号，主机号8位，地址范围`192.168.1.0~192.168.1.255`；
  - `192.168.1.1/32`：32位网络号，无主机号，仅表示“192.168.1.1”单个地址；
  - `0.0.0.0/0`：0位网络号，匹配所有IPv4地址（默认路由）。

#### （3）子网掩码（Netmask）
- 作用：斜线记法的“机器友好版”，用于通过**按位与（AND）运算提取网络号**；
- 规则：网络号对应位为1，主机号对应位为0，转换为点分四组；
- 例：`220.232.144.0/20` → 子网掩码`255.255.240.0`（前20位为1，后12位为0）；
- 计算逻辑：IP地址 & 子网掩码 = 网络号（如`220.232.150.5 & 255.255.240.0 = 220.232.144.0`）。

#### 对比：斜线记法 vs. 子网掩码
| 场景         | 斜线记法（如/20） | 子网掩码（如255.255.240.0） |
|--------------|--------------------|------------------------------|
| 人类阅读     | 更简洁（直接看长度） | 需换算（1的位数=网络号长度） |
| 机器计算     | 需转换为掩码       | 直接用于按位与运算           |


### 4. 路由聚合（Aggregating Routes）：进一步简化域间路由
路由聚合是“分层地址”的延伸，将多个连续的网络前缀合并为一个更短的前缀，减少域间路由表项。

#### （1）聚合示例
- 背景：AT&T拥有`4.0.0.0/8`（8位网络号），将`4.12.0.0/16`分配给UC Berkeley，`4.29.0.0/16`分配给Stanford；
- 聚合前：R6的表项需包含`4.0.0.0/8→R2`、`4.12.0.0/16→R2`、`4.29.0.0/16→R2`；
- 聚合后：R6的表项可简化为`4.0.0.0/8→R2`（单个表项覆盖所有子网络）。

#### （2）聚合的限制：多宿主（Multi-Homing）
若某网络同时连接多个ISP（如Stanford同时连AT&T和Orange），需为该网络单独配置表项，无法聚合：
- 例：Stanford的`4.29.0.0/16`需单独配置`4.29.0.0/16→R7`（Orange链路），而`4.0.0.0/8→R2`（AT&T链路），此时无法合并为单个表项。

#### （3）最长前缀匹配（Longest Prefix Matching）
当地址匹配多个前缀时，选择**网络号最长（最具体）** 的前缀：
- 例：`4.29.1.2`同时匹配`4.0.0.0/8`（8位）和`4.29.0.0/16`（16位），选择`4.29.0.0/16`对应的下一跳R7。


### 5. IPv6的变化（IPv6 Changes）：解决IPv4地址耗尽
IPv4仅32位（约40亿地址），2017年后各区域注册机构（RIR）地址池枯竭，IPv6应运而生。

#### （1）IPv6的核心改进：128位地址
- 地址数量：2^128≈3.4×10^38，足够为“宇宙历史上的每一秒”分配地址，彻底解决耗尽问题；
- 地址格式：8个4位十六进制块，用冒号分隔（如`2001:0DB8:CAFE:BEEF:DEAD:1234:5678:9012`）；
- 简写规则：
  1. 省略块内前导零（如`0DB8→DB8`，`0000→0`）；
  2. 一次省略连续的全零块（用`::`代替，仅允许一次，避免歧义），如`2001:DB8:0:0:0:0:0:1→2001:DB8::1`；
- 斜线记法兼容：如`2001:DB8::/32`（32位网络号，96位主机号）。

#### （2）IPv6的地址分配变化
- 无状态自动配置（SLAAC）：主机可随机选择前缀，检测到冲突后重新选择（因地址足够多，冲突概率极低）；
- 网络号长度：通常最多64位，主机号64位（即使最小网络也有2^64台主机，无需担心不够用）。

#### （3）IPv6的 adoption 挑战
- 兼容性问题：IPv4与IPv6不兼容，需维护两个转发表，且无法直接转换；
- 升级成本：需更新主机、路由器的软硬件（支持IPv6协议栈）；
- 选择困境：双栈（同时支持IPv4/IPv6）环境下，需决策使用哪种协议（IPv6通常更快，但需考虑兼容性）；
- 现状：2025年约40%主机支持IPv6，adoption率与区域互联网用户数量正相关，核心驱动因素是IPv4耗尽。


## 三、IP地址核心总结
1. **地址类型**：主机需配置IPv4、IPv6或双栈地址，应对地址耗尽问题；
2. **分层结构**：地址分为网络号与主机号，适配“网络的网络”拓扑；
3. **分配逻辑**：按层级（ICANN→RIR→ISP→组织）分配，CIDR按需调整网络号长度，减少浪费；
4. **路由优化**：通过路由聚合（合并前缀）和最长前缀匹配，大幅简化路由表，提升扩展性。